<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="htmlgraph-version" content="1.0">
    <title>ComputationalReflection Architectural Analysis</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <article id="spk-9e4b67e0"
             data-type="spike"
             data-status="todo"
             data-priority="medium"
             data-created="2026-01-04T03:45:06.061360"
             data-updated="2026-01-04T03:45:06.061366" data-spike-type="general" data-timebox-hours="4">

        <header>
            <h1>ComputationalReflection Architectural Analysis</h1>
            <div class="metadata">
                <span class="badge status-todo">Todo</span>
                <span class="badge priority-medium">Medium Priority</span>
            </div>
        </header>

    
        <section data-spike-metadata>
            <h3>Spike Metadata</h3>
            <dl>
                <dt>Type</dt>
                <dd>General</dd>
                <dt>Timebox</dt>
                <dd>4 hours</dd>
            </dl>
        </section>
        <section data-findings>
            <h3>Findings</h3>
            <div class="findings-content">
                
## Architectural Analysis: ComputationalReflection

### 1. Design Patterns

**Strategy Pattern (Reflection Categories)**
- Five distinct reflection strategies (_get_blockers, _get_recent_failures, _get_anti_patterns, _get_related_spikes, _get_recommendations)
- Each strategy implements independent data gathering with consistent return type (list[ReflectionItem])
- Allows flexible composition and prioritization of insights

**Template Method Pattern**
- Main method get_actionable_context() defines the algorithm skeleton
- Delegates to specialized methods for each reflection category
- Enforces MAX_ITEMS constraint after gathering all candidates

**Cache Pattern (TTL Cache)**
- Simple time-based caching (_cache, _cache_time, _cache_ttl)
- 5-minute TTL to balance freshness vs computation cost
- Reduces repeated computation within short timeframes

**Builder Pattern (Summary Construction)**
- _build_summary() constructs one-line summary from items
- Aggregates counts by category (blockers, failures, anti-patterns, spikes)
- Produces human-readable output: "2 blockers | Avoid: Edit-Edit-Edit | See: spk-abc123"

**Facade Pattern**
- Provides simplified interface to complex SDK operations
- Hides details of bottleneck analysis, session tracking, spike retrieval
- Convenience function get_reflection_context() serves as single entry point for hooks

### 2. Working Memory Limit (5 Items)

**Hard Constraint Enforcement**
- MAX_ITEMS = 5 (line 73) - Class constant matching LLM working memory research
- items = items[:self.MAX_ITEMS] (line 123) - Hard limit after sorting by priority

**Priority-Based Selection**
- Each ReflectionItem has priority 1-5 (higher = more important)
- Priority levels:
  - 5: Blockers from find_bottlenecks()
  - 4: Blocked features, recent failures
  - 3: Anti-patterns
  - 2: Related spikes, strategic recommendations
- Items sorted by priority descending before truncation (line 122)

**Per-Category Limits (Prevents Category Dominance)**
- Blockers: max 2 items (lines 149, 165)
- Failures: max 2 items (line 231)
- Anti-patterns: max 1 item (line 271)
- Related spikes: max 1 item (line 326)
- Recommendations: max 1 item (line 352)
- Total possible: 7 items collected, truncated to 5 best by priority

**Rationale (From Module Docstring)**
"Addresses the LLM limitation where models can only effectively track 5-10 variables in working memory."
Design principle: "LIMIT to 5 items - Respect LLM working memory constraints" (line 10)

### 3. Five Reflection Categories

**Category 1: Blockers (Priority 4-5)**
- Purpose: Items blocking current work
- Sources:
  - SDK.find_bottlenecks() - Graph analysis of blocking dependencies
  - Features with status="blocked"
- Example: "Blocker: Fix auth module" - "Blocks 3 items. Resolve first."

**Category 2: Failures (Priority 4)**
- Purpose: Recent failures from session history
- Sources:
  - Session activity logs (last 48 hours)
  - Activities with success=False
- Lookback: LOOKBACK_HOURS = 48 (line 74)
- Example: "Recent failure: Edit" - "Type error in reflection.py"

**Category 3: Anti-patterns (Priority 3)**
- Purpose: Inefficient patterns to avoid
- Sources:
  - LearningPersistence.analyze_for_orchestrator()
  - Active session analysis for repeated sequences
- Example: "Avoid: Read → Read → Read" - "Detected inefficient pattern"

**Category 4: Spikes (Priority 2)**
- Purpose: Related investigations with findings
- Sources:
  - Spikes linked to current feature (edges)
  - Spikes mentioning current track
  - Recent completed spikes (last 24 hours)
- Relevance scoring: 5 (linked), 3 (track mention), 2 (recent completed)
- Example: "Related: Hook debugging analysis" - "Found root cause in hook merging"

**Category 5: Recommendations (Priority 2)**
- Purpose: Strategic next work suggestions
- Sources:
  - SDK.recommend_next_work() - Graph-based strategic analysis
- Example: "Next: Add deployment automation" - "High-impact, unblocked"

### 4. Key Architectural Decisions

**Computation Over Prompting**
- Design principle: "COMPUTE, don't prompt - Do the synthesis work here, not in prompts" (line 9)
- Pre-computes insights instead of asking LLM to analyze raw data
- Reduces token usage and improves consistency

**Graceful Degradation**
- All category methods wrapped in try/except (lines 145, 163, 184, 238, 279, 332)
- Failures in one category don't affect others
- Returns partial results if some data sources fail

**Context-Aware Filtering**
- Accepts current_feature_id and current_track parameters
- Filters spikes and recommendations based on current context
- Increases relevance of injected reflections

**Structured Output**
- Returns dict with summary, items, metadata
- format_for_injection() converts to markdown for hook injection
- Dual format: machine-readable (dict) and human-readable (markdown)

**Time-Based Relevance**
- 48-hour lookback window for failures (line 187)
- 24-hour window for recent spikes (line 305)
- Prioritizes recent activity over historical data

### 5. Integration Points

**Hook Integration**
- get_reflection_context() convenience function (line 422)
- format_for_injection() produces markdown for additionalContext (line 385)
- Designed for SessionStart and PreToolUse hooks

**SDK Dependency**
- Uses SDK.find_bottlenecks() for blocker analysis
- Uses SDK.recommend_next_work() for strategic recommendations
- Uses SDK.sessions, SDK.features, SDK.spikes for data access
- Uses LearningPersistence for pattern analysis

**Output Format Example**
in is a shell keyword

### 6. Performance Characteristics

**Caching Strategy**
- 5-minute TTL cache reduces repeated computation
- Trade-off: Freshness vs performance
- Suitable for hook injection (sessions don't change every second)

**Complexity Analysis**
- O(n) where n = total items across all categories
- Each category method has internal limits (max 1-2 items)
- Total items collected: ~7, sorted and truncated to 5
- Efficient even with large graphs

**Error Handling**
- Silent failures in category methods (pass)
- Ensures partial results always returned
- No cascading failures across categories

### Summary

ComputationalReflection is a **facade** that applies the **strategy pattern** to gather insights from HtmlGraph, enforces a **hard 5-item limit** matching LLM working memory constraints, and uses **priority-based selection** across **five reflection categories** (blockers, failures, anti-patterns, spikes, recommendations). It embodies the "compute, don't prompt" philosophy by pre-synthesizing actionable context for injection into orchestrator hooks.

            </div>
        </section>
    </article>
</body>
</html>
