<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="htmlgraph-version" content="1.0">
    <title>Spec: Graph Database Completeness Specification</title>
    <link rel="stylesheet" href="../../.htmlgraph/styles.css">
    <style>
        /* HtmlGraph Dashboard Design System */
        :root {
            --bg-primary: #151518;
            --bg-secondary: #1C1C20;
            --bg-tertiary: #252528;
            --text-primary: #E0DED8;
            --text-secondary: #A0A0A0;
            --text-muted: #707070;
            --border: #333338;
            --border-strong: #606068;
            --accent: #CDFF00;
            --accent-text: #0A0A0A;
        }

        * { box-sizing: border-box; }

        body {
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'JetBrains Mono', 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 14px;
            line-height: 1.6;
            margin: 0;
            padding: 2rem;
            max-width: 1200px;
            margin-inline: auto;
        }

        .spec-nav {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border-strong);
        }

        .nav-link {
            color: var(--text-secondary);
            text-decoration: none;
            padding: 0.5rem 1rem;
            border: 2px solid var(--border-strong);
            border-radius: 0;
            transition: all 0.2s;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .nav-link:hover {
            color: var(--accent);
            border-color: var(--accent);
        }

        article {
            background: var(--bg-secondary);
            border: 2px solid var(--border-strong);
            padding: 0;
        }

        header {
            padding: 2rem;
            border-bottom: 2px solid var(--border-strong);
            background: var(--bg-tertiary);
        }

        h1 {
            margin: 0 0 1rem 0;
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        h2 {
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            margin: 0 0 1rem 0;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
        }

        .metadata {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            font-size: 0.75rem;
        }

        .badge {
            background: var(--bg-primary);
            color: var(--text-secondary);
            padding: 0.25rem 0.75rem;
            border: 1px solid var(--border);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: 0.7rem;
        }

        .status-draft {
            color: var(--text-muted);
            border-color: var(--text-muted);
        }

        .status-review {
            color: #f59e0b;
            border-color: #f59e0b;
        }

        .status-approved {
            color: var(--accent);
            border-color: var(--accent);
        }

        section {
            padding: 2rem;
            border-bottom: 1px solid var(--border);
        }

        section:last-child {
            border-bottom: none;
        }

        p {
            margin: 0;
            color: var(--text-primary);
            line-height: 1.8;
        }

        .muted {
            color: var(--text-muted);
            font-style: italic;
        }

        .requirements-list article,
        .criteria-list li {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            padding: 1rem;
            margin-bottom: 0.75rem;
        }

        .criteria-list {
            list-style: none;
            counter-reset: criteria;
            padding: 0;
            margin: 0;
        }

        .criteria-list li {
            counter-increment: criteria;
            position: relative;
            padding-left: 3rem;
        }

        .criteria-list li::before {
            content: counter(criteria);
            position: absolute;
            left: 1rem;
            top: 1rem;
            background: var(--accent);
            color: var(--accent-text);
            width: 1.5rem;
            height: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.75rem;
        }

        a {
            color: var(--accent);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    
        <div class="spec-nav">
            <a href="index.html" class="nav-link">← Track</a>
            <a href="plan.html" class="nav-link">Plan →</a>
        </div>
    <article id="trk-5b13f896-spec" data-type="spec" data-status="draft" data-track="trk-5b13f896">
        <header>
            <h1>Graph Database Completeness Specification</h1>
            <div class="metadata">
                <span class="badge status-draft">Draft</span>
                <span class="badge">Author: claude-code</span>
                <span class="badge">Created: 2025-12-22</span>
            </div>
        </header>

        <section data-section="overview">
            <h2>Overview</h2>
            <p>Define requirements for making HtmlGraph a complete graph database implementation while maintaining its HTML-first philosophy. This includes: (1) First-class relationship support with bidirectional edges and inverse indexing, (2) Comprehensive query API beyond CSS selectors, (3) Efficient multi-hop traversal with caching, (4) Rich property support on both nodes and edges.</p>
        </section>

        <section data-section="context">
            <h2>Context</h2>
            <p>Analysis revealed HtmlGraph partially implements graph database characteristics. Key gaps: uni-directional edges requiring O(V×E) reverse lookups, no query composition API, limited to CSS selectors (no OR/NOT logic, text search, numeric comparisons), no adjacency caching. Libraries like BeautifulSoup, Playwright, and XPath offer richer querying that should inform our design.</p>
        </section>

        <section data-section="requirements">
            <h2>Functional Requirements</h2>

            <article data-requirement="REQ-001" data-priority="high" data-category="relationships">
                <h3>REQ-001: Bidirectional Relationship Support</h3>
                <p><strong>Category:</strong> Relationships as First-Class Citizens</p>
                <p>The system MUST support bidirectional edge traversal with O(1) lookup time in both directions.</p>
                <ul>
                    <li>Maintain inverse edge index mapping target → sources</li>
                    <li>Auto-sync inverse relationships when edges are added/removed</li>
                    <li>Support semantic relationship pairs (blocks/blocked_by, parent/child)</li>
                    <li>Persist inverse index or rebuild efficiently on load</li>
                </ul>
            </article>

            <article data-requirement="REQ-002" data-priority="high" data-category="relationships">
                <h3>REQ-002: Edge Properties and Metadata</h3>
                <p><strong>Category:</strong> Rich Contextual Modelling</p>
                <p>Edges MUST support arbitrary properties with the same flexibility as nodes.</p>
                <ul>
                    <li>Store edge properties in HTML data-* attributes</li>
                    <li>Support temporal properties (since, until, duration)</li>
                    <li>Support numeric properties for weighted graphs</li>
                    <li>Query edges by their properties</li>
                </ul>
            </article>

            <article data-requirement="REQ-003" data-priority="high" data-category="query">
                <h3>REQ-003: Fluent Query Builder API</h3>
                <p><strong>Category:</strong> Query Capabilities</p>
                <p>The system MUST provide a composable, type-safe query builder beyond raw CSS selectors.</p>
                <ul>
                    <li>Chainable methods: where(), or_where(), and_where(), not()</li>
                    <li>Pagination: limit(), offset(), first(), last()</li>
                    <li>Ordering: order_by(field, direction)</li>
                    <li>Projections: select(fields), exclude(fields)</li>
                    <li>Compile to CSS selectors where possible, fall back to predicate filters</li>
                </ul>
            </article>

            <article data-requirement="REQ-004" data-priority="high" data-category="query">
                <h3>REQ-004: Advanced Query Operators</h3>
                <p><strong>Category:</strong> Query Capabilities</p>
                <p>The query system MUST support operators beyond CSS selector equality matching.</p>
                <ul>
                    <li>Logical: OR, NOT, AND (compound)</li>
                    <li>Comparison: &gt;, &lt;, &gt;=, &lt;=, != for numeric/date fields</li>
                    <li>Text: contains(), starts_with(), ends_with(), regex()</li>
                    <li>Collection: in(), not_in() for set membership</li>
                    <li>Null handling: is_null(), is_not_null()</li>
                </ul>
            </article>

            <article data-requirement="REQ-005" data-priority="medium" data-category="query">
                <h3>REQ-005: Full-Text Search</h3>
                <p><strong>Category:</strong> Query Capabilities</p>
                <p>The system SHOULD support searching node content, titles, and text fields.</p>
                <ul>
                    <li>Search node titles and content sections</li>
                    <li>Optional: Integrate with SQLite FTS for large graphs</li>
                    <li>Highlight matching text in results</li>
                    <li>Rank results by relevance</li>
                </ul>
            </article>

            <article data-requirement="REQ-006" data-priority="medium" data-category="query">
                <h3>REQ-006: BeautifulSoup-Style Find API</h3>
                <p><strong>Category:</strong> Query Capabilities</p>
                <p>The system SHOULD provide a find() API inspired by BeautifulSoup for flexible matching.</p>
                <ul>
                    <li>find(status="blocked") - single attribute match</li>
                    <li>find(status=["todo", "blocked"]) - OR matching via list</li>
                    <li>find(priority=lambda p: p in ["high", "critical"]) - predicate matching</li>
                    <li>find(text_contains="OAuth") - text content search</li>
                    <li>find_all() for multiple results</li>
                </ul>
            </article>

            <article data-requirement="REQ-007" data-priority="low" data-category="query">
                <h3>REQ-007: XPath Support (Optional)</h3>
                <p><strong>Category:</strong> Query Capabilities</p>
                <p>The system MAY support XPath queries for power users needing maximum expressiveness.</p>
                <ul>
                    <li>xpath() method accepting XPath expressions</li>
                    <li>Use lxml or similar library for XPath evaluation</li>
                    <li>Document XPath patterns for common graph queries</li>
                </ul>
            </article>

            <article data-requirement="REQ-008" data-priority="high" data-category="traversal">
                <h3>REQ-008: Efficient Multi-Hop Traversal</h3>
                <p><strong>Category:</strong> Graph Traversal</p>
                <p>Graph traversal operations MUST be efficient with caching.</p>
                <ul>
                    <li>Cache adjacency lists after first build</li>
                    <li>Invalidate cache on graph mutations</li>
                    <li>Support lazy loading for large graphs</li>
                    <li>Provide traversal iterators to avoid loading entire result set</li>
                </ul>
            </article>

            <article data-requirement="REQ-009" data-priority="medium" data-category="traversal">
                <h3>REQ-009: Graph Pattern Matching</h3>
                <p><strong>Category:</strong> Graph Traversal</p>
                <p>The system SHOULD support pattern-based graph queries.</p>
                <ul>
                    <li>Match node sequences: (A)-[blocks]->(B)-[blocks]->(C)</li>
                    <li>Variable-length paths: (A)-[blocks*1..3]->(B)</li>
                    <li>Filter patterns by node/edge properties</li>
                    <li>Return matched subgraphs</li>
                </ul>
            </article>

            <article data-requirement="REQ-010" data-priority="medium" data-category="performance">
                <h3>REQ-010: Optional Index Layer</h3>
                <p><strong>Category:</strong> Performance</p>
                <p>The system SHOULD provide an optional index for performance at scale.</p>
                <ul>
                    <li>SQLite-based index for nodes, edges, and properties</li>
                    <li>Auto-sync index with HTML file changes</li>
                    <li>Query planner to choose index vs. file scan</li>
                    <li>Index edge relationships for O(1) reverse lookups</li>
                </ul>
            </article>
        </section>

        <section data-section="non-functional">
            <h2>Non-Functional Requirements</h2>

            <article data-requirement="NFR-001" data-priority="high">
                <h3>NFR-001: Backward Compatibility</h3>
                <p>All existing APIs MUST remain functional. New query methods are additive.</p>
            </article>

            <article data-requirement="NFR-002" data-priority="high">
                <h3>NFR-002: HTML-First Philosophy</h3>
                <p>HTML files remain the source of truth. All indexes are derived and rebuildable.</p>
            </article>

            <article data-requirement="NFR-003" data-priority="medium">
                <h3>NFR-003: Zero Required Dependencies</h3>
                <p>Core functionality MUST work with existing dependencies (justhtml, pydantic). Advanced features (XPath, FTS) MAY add optional dependencies.</p>
            </article>

            <article data-requirement="NFR-004" data-priority="medium">
                <h3>NFR-004: Performance Targets</h3>
                <ul>
                    <li>Query 1000 nodes: &lt;100ms</li>
                    <li>Reverse edge lookup: O(1) with index</li>
                    <li>Shortest path (1000 nodes): &lt;50ms</li>
                    <li>Full graph load: &lt;1s for 1000 nodes</li>
                </ul>
            </article>
        </section>

        <section data-section="acceptance">
            <h2>Acceptance Criteria</h2>
            <ol class="criteria-list">
                <li>graph.dependents(node_id) completes in O(1) time with inverse index</li>
                <li>graph.query().where(status="blocked").or_where(status="todo").execute() returns correct results</li>
                <li>graph.find(priority=["high", "critical"]) supports OR logic via list</li>
                <li>graph.find(effort=lambda e: int(e) > 5) supports numeric comparisons</li>
                <li>Full-text search finds nodes by title and content</li>
                <li>Adjacency cache improves repeated traversal by 10x</li>
                <li>All existing tests continue to pass</li>
                <li>New query APIs have >90% test coverage</li>
            </ol>
        </section>

        <section data-section="out-of-scope">
            <h2>Out of Scope</h2>
            <ul>
                <li>ACID transactions (not a goal for file-based storage)</li>
                <li>Distributed graph (single-machine only)</li>
                <li>Real-time subscriptions (use file watchers externally)</li>
                <li>Graph visualization (separate concern)</li>
            </ul>
        </section>

    </article>
</body>
</html>
