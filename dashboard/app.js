// HtmlGraph Dashboard - Spike Visualization
// Handles spike loading, filtering, and timeline rendering

class SpikesDashboard {
    constructor() {
        this.spikes = [];
        this.sessions = [];
        this.filters = {
            hideAutoGenerated: false,
            showOnlyActive: false
        };
        this.currentView = 'list';
        this.init();
    }

    async init() {
        this.bindEvents();
        await this.loadData();
        this.render();
    }

    bindEvents() {
        // Filter toggles
        document.getElementById('hideAutoSpikes').addEventListener('change', (e) => {
            this.filters.hideAutoGenerated = e.target.checked;
            this.render();
        });

        document.getElementById('showOnlyActive').addEventListener('change', (e) => {
            this.filters.showOnlyActive = e.target.checked;
            this.render();
        });

        // View switching
        document.querySelectorAll('.view-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const view = e.target.dataset.view;
                this.switchView(view);
            });
        });
    }

    async loadData() {
        const loading = document.getElementById('loading');
        const error = document.getElementById('error');

        try {
            loading.classList.remove('hidden');
            error.classList.add('hidden');

            // Load spikes from .htmlgraph/spikes/
            await this.loadSpikes();

            // Load sessions for timeline
            await this.loadSessions();

            loading.classList.add('hidden');
        } catch (err) {
            loading.classList.add('hidden');
            error.classList.remove('hidden');
            error.querySelector('.error-message').textContent = `Error loading data: ${err.message}`;
            console.error('Error loading data:', err);
        }
    }

    async loadSpikes() {
        const spikesPath = '../.htmlgraph/spikes/';

        // In a real browser environment, we'd need to fetch a manifest or directory listing
        // For now, we'll attempt to load known spike files or use a manifest
        try {
            const response = await fetch(`${spikesPath}manifest.json`).catch(() => null);

            if (response && response.ok) {
                const manifest = await response.json();
                await this.loadSpikesFromManifest(manifest, spikesPath);
            } else {
                // Fallback: try to load common spike files
                await this.loadSpikesFromDirectory(spikesPath);
            }
        } catch (err) {
            console.warn('Could not load spikes:', err);
            // Generate sample data for demonstration
            this.generateSampleSpikes();
        }
    }

    async loadSpikesFromDirectory(basePath) {
        // This would require a server-side directory listing
        // For demo purposes, we'll use a hardcoded list
        const spikeFiles = [
            'spike-init-sess-fd5.html',
            'spike-self-tracking-drift.html',
            'spike-htmlgraph-tracker-investigation.html'
        ];

        for (const file of spikeFiles) {
            try {
                const response = await fetch(`${basePath}${file}`);
                if (response.ok) {
                    const html = await response.text();
                    const spike = this.parseSpikeHTML(html);
                    if (spike) this.spikes.push(spike);
                }
            } catch (err) {
                console.warn(`Could not load ${file}:`, err);
            }
        }
    }

    parseSpikeHTML(html) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const article = doc.querySelector('article[data-type="spike"]');

        if (!article) return null;

        return {
            id: article.id,
            title: doc.querySelector('h1')?.textContent || 'Untitled Spike',
            status: article.getAttribute('data-status') || 'unknown',
            priority: article.getAttribute('data-priority') || 'medium',
            created: article.getAttribute('data-created'),
            updated: article.getAttribute('data-updated'),
            autoGenerated: article.getAttribute('data-auto-generated') === 'true',
            spikeSubtype: article.getAttribute('data-spike-subtype'),
            sessionId: article.getAttribute('data-session-id'),
            toFeatureId: article.getAttribute('data-to-feature-id'),
            modelName: article.getAttribute('data-model-name'),
            description: doc.querySelector('section[data-content] p')?.textContent || '',
            element: article
        };
    }

    async loadSessions() {
        // Load session files for timeline construction
        // Similar approach as spikes
        const sessionsPath = '../.htmlgraph/sessions/';

        try {
            const response = await fetch(`${sessionsPath}manifest.json`).catch(() => null);

            if (response && response.ok) {
                const manifest = await response.json();
                await this.loadSessionsFromManifest(manifest, sessionsPath);
            }
        } catch (err) {
            console.warn('Could not load sessions:', err);
            this.generateSampleSessions();
        }
    }

    generateSampleSpikes() {
        // Generate sample data for demonstration
        const now = new Date();

        this.spikes = [
            {
                id: 'spike-init-sess-001',
                title: 'Session Init: claude',
                status: 'done',
                priority: 'low',
                created: new Date(now - 3600000).toISOString(),
                updated: new Date(now - 3500000).toISOString(),
                autoGenerated: true,
                spikeSubtype: 'session-init',
                sessionId: 'sess-001',
                toFeatureId: 'feat-001',
                modelName: 'claude',
                description: 'Auto-generated spike for session startup activities.'
            },
            {
                id: 'spike-planning-investigation',
                title: 'Planning Investigation Spike',
                status: 'in-progress',
                priority: 'high',
                created: new Date(now - 7200000).toISOString(),
                updated: new Date(now - 1800000).toISOString(),
                autoGenerated: false,
                spikeSubtype: null,
                sessionId: null,
                toFeatureId: null,
                modelName: null,
                description: 'Investigate optimal planning workflow patterns.'
            },
            {
                id: 'spike-init-sess-002',
                title: 'Session Init: gemini',
                status: 'done',
                priority: 'low',
                created: new Date(now - 5400000).toISOString(),
                updated: new Date(now - 5300000).toISOString(),
                autoGenerated: true,
                spikeSubtype: 'session-init',
                sessionId: 'sess-002',
                toFeatureId: 'feat-002',
                modelName: 'gemini',
                description: 'Auto-generated spike for session startup activities.'
            },
            {
                id: 'spike-drift-classification',
                title: 'Drift Classification Analysis',
                status: 'blocked',
                priority: 'medium',
                created: new Date(now - 10800000).toISOString(),
                updated: new Date(now - 3600000).toISOString(),
                autoGenerated: false,
                spikeSubtype: null,
                sessionId: null,
                toFeatureId: null,
                modelName: null,
                description: 'Analyze drift score patterns and classification accuracy.'
            }
        ];
    }

    generateSampleSessions() {
        const now = new Date();

        this.sessions = [
            {
                id: 'sess-001',
                startTime: new Date(now - 7200000).toISOString(),
                endTime: new Date(now - 3600000).toISOString(),
                featureId: 'feat-001',
                agent: 'claude'
            },
            {
                id: 'sess-002',
                startTime: new Date(now - 5400000).toISOString(),
                endTime: new Date(now - 1800000).toISOString(),
                featureId: 'feat-002',
                agent: 'gemini'
            }
        ];
    }

    getFilteredSpikes() {
        return this.spikes.filter(spike => {
            if (this.filters.hideAutoGenerated && spike.autoGenerated) {
                return false;
            }
            if (this.filters.showOnlyActive && spike.status !== 'in-progress') {
                return false;
            }
            return true;
        });
    }

    updateStats() {
        const total = this.spikes.length;
        const auto = this.spikes.filter(s => s.autoGenerated).length;
        const manual = total - auto;
        const active = this.spikes.filter(s => s.status === 'in-progress').length;

        document.getElementById('totalSpikes').textContent = total;
        document.getElementById('autoSpikes').textContent = auto;
        document.getElementById('manualSpikes').textContent = manual;
        document.getElementById('activeTransitions').textContent = active;
    }

    render() {
        this.updateStats();

        if (this.currentView === 'list') {
            this.renderList();
        } else {
            this.renderTimeline();
        }
    }

    renderList() {
        const container = document.getElementById('spikesList');
        const filtered = this.getFilteredSpikes();

        document.getElementById('visibleCount').textContent = `${filtered.length} visible`;

        if (filtered.length === 0) {
            container.innerHTML = '<div class="empty-state">No spikes match current filters</div>';
            return;
        }

        container.innerHTML = filtered.map(spike => this.createSpikeCard(spike)).join('');
    }

    createSpikeCard(spike) {
        const autoClass = spike.autoGenerated ? 'auto-generated' : 'manual';
        const statusClass = `status-${spike.status}`;
        const priorityClass = `priority-${spike.priority}`;

        const autoLabel = spike.autoGenerated
            ? '<span class="auto-badge">Auto-Generated</span>'
            : '';

        const sessionInfo = spike.sessionId
            ? `<div class="spike-meta-item">
                   <span class="meta-label">Session:</span>
                   <span class="meta-value">${spike.sessionId}</span>
               </div>`
            : '';

        const featureInfo = spike.toFeatureId
            ? `<div class="spike-meta-item">
                   <span class="meta-label">Feature:</span>
                   <span class="meta-value">${spike.toFeatureId}</span>
               </div>`
            : '';

        const modelInfo = spike.modelName
            ? `<div class="spike-meta-item">
                   <span class="meta-label">Agent:</span>
                   <span class="meta-value">${spike.modelName}</span>
               </div>`
            : '';

        return `
            <div class="spike-card ${autoClass}" data-spike-id="${spike.id}">
                <div class="spike-header">
                    <h3 class="spike-title">${spike.title}</h3>
                    ${autoLabel}
                </div>
                <div class="spike-badges">
                    <span class="badge ${statusClass}">${spike.status}</span>
                    <span class="badge ${priorityClass}">${spike.priority}</span>
                </div>
                <p class="spike-description">${spike.description}</p>
                <div class="spike-meta">
                    ${sessionInfo}
                    ${featureInfo}
                    ${modelInfo}
                    <div class="spike-meta-item">
                        <span class="meta-label">Created:</span>
                        <span class="meta-value">${this.formatDate(spike.created)}</span>
                    </div>
                </div>
            </div>
        `;
    }

    renderTimeline() {
        const container = document.getElementById('timeline');
        const filtered = this.getFilteredSpikes();

        if (filtered.length === 0) {
            container.innerHTML = '<div class="empty-state">No spikes to display in timeline</div>';
            return;
        }

        // Group spikes by session transitions
        const transitions = this.buildTransitions(filtered);

        container.innerHTML = transitions.map(t => this.createTimelineItem(t)).join('');
    }

    buildTransitions(spikes) {
        // Build session → spike → session flow
        const transitions = [];

        // Group by session
        const sessionSpikes = spikes.filter(s => s.sessionId);

        sessionSpikes.forEach(spike => {
            const prevSession = this.sessions.find(s => s.id === spike.sessionId);
            const nextSession = spike.toFeatureId
                ? this.sessions.find(s => s.featureId === spike.toFeatureId)
                : null;

            transitions.push({
                spike,
                prevSession,
                nextSession
            });
        });

        // Add standalone spikes
        const standaloneSpikes = spikes.filter(s => !s.sessionId);
        standaloneSpikes.forEach(spike => {
            transitions.push({
                spike,
                prevSession: null,
                nextSession: null
            });
        });

        // Sort by created date
        transitions.sort((a, b) =>
            new Date(a.spike.created) - new Date(b.spike.created)
        );

        return transitions;
    }

    createTimelineItem(transition) {
        const { spike, prevSession, nextSession } = transition;
        const autoClass = spike.autoGenerated ? 'auto-generated' : 'manual';

        const prevSessionHTML = prevSession
            ? `<div class="timeline-session">
                   <div class="session-marker prev">
                       <span class="session-id">${prevSession.id}</span>
                       <span class="session-agent">${prevSession.agent}</span>
                   </div>
               </div>`
            : '<div class="timeline-session"><div class="session-marker empty">Start</div></div>';

        const nextSessionHTML = nextSession
            ? `<div class="timeline-session">
                   <div class="session-marker next">
                       <span class="session-id">${nextSession.id}</span>
                       <span class="session-agent">${nextSession.agent}</span>
                   </div>
               </div>`
            : '<div class="timeline-session"><div class="session-marker empty">End</div></div>';

        const autoLabel = spike.autoGenerated
            ? '<span class="auto-badge-timeline">Auto</span>'
            : '';

        return `
            <div class="timeline-item ${autoClass}">
                ${prevSessionHTML}
                <div class="timeline-connector">→</div>
                <div class="timeline-spike">
                    <div class="spike-marker">
                        <div class="spike-dot"></div>
                        <div class="spike-content">
                            <h4 class="spike-title-timeline">
                                ${spike.title}
                                ${autoLabel}
                            </h4>
                            <div class="spike-time">${this.formatDate(spike.created)}</div>
                            <div class="spike-status-timeline">
                                <span class="badge status-${spike.status}">${spike.status}</span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="timeline-connector">→</div>
                ${nextSessionHTML}
            </div>
        `;
    }

    switchView(view) {
        this.currentView = view;

        // Update button states
        document.querySelectorAll('.view-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.view === view);
        });

        // Toggle view containers
        document.getElementById('listView').classList.toggle('hidden', view !== 'list');
        document.getElementById('timelineView').classList.toggle('hidden', view !== 'timeline');

        this.render();
    }

    formatDate(dateString) {
        if (!dateString) return 'Unknown';
        const date = new Date(dateString);
        return date.toLocaleString('en-US', {
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    }
}

// Initialize dashboard when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.dashboard = new SpikesDashboard();
});
